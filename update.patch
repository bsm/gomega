--- ./ghttp/handlers.go	2021-04-06 11:16:35.408198636 +0100
+++ ./ghttp/handlers.go	2021-04-06 11:12:15.628252311 +0100
@@ -9,10 +9,8 @@
 	"io/ioutil"
 	"net/http"
 	"net/url"
-	"reflect"
 	"strings"

-	"github.com/golang/protobuf/proto"
 	"github.com/bsm/gomega"
 	. "github.com/bsm/gomega"
 	"github.com/bsm/gomega/types"
@@ -174,32 +172,6 @@
 	return VerifyForm(url.Values{key: values})
 }

-//VerifyProtoRepresenting returns a handler that verifies that the body of the request is a valid protobuf
-//representation of the passed message.
-//
-//VerifyProtoRepresenting also verifies that the request's content type is application/x-protobuf
-func (g GHTTPWithGomega) VerifyProtoRepresenting(expected proto.Message) http.HandlerFunc {
-	return CombineHandlers(
-		VerifyContentType("application/x-protobuf"),
-		func(w http.ResponseWriter, req *http.Request) {
-			body, err := ioutil.ReadAll(req.Body)
-			g.gomega.Expect(err).ShouldNot(HaveOccurred())
-			req.Body.Close()
-
-			expectedType := reflect.TypeOf(expected)
-			actualValuePtr := reflect.New(expectedType.Elem())
-
-			actual, ok := actualValuePtr.Interface().(proto.Message)
-			g.gomega.Expect(ok).Should(BeTrue(), "Message value is not a proto.Message")
-
-			err = proto.Unmarshal(body, actual)
-			g.gomega.Expect(err).ShouldNot(HaveOccurred(), "Failed to unmarshal protobuf")
-
-			g.gomega.Expect(actual).Should(Equal(expected), "ProtoBuf Mismatch")
-		},
-	)
-}
-
 func copyHeader(src http.Header, dst http.Header) {
 	for key, value := range src {
 		dst[key] = value
@@ -309,31 +281,6 @@
 	}
 }

-//RespondWithProto returns a handler that responds to a request with the specified status code and a body
-//containing the protobuf serialization of the provided message.
-//
-//Also, RespondWithProto can be given an optional http.Header.  The headers defined therein will be added to the response headers.
-func (g GHTTPWithGomega) RespondWithProto(statusCode int, message proto.Message, optionalHeader ...http.Header) http.HandlerFunc {
-	return func(w http.ResponseWriter, req *http.Request) {
-		data, err := proto.Marshal(message)
-		g.gomega.Expect(err).ShouldNot(HaveOccurred())
-
-		var headers http.Header
-		if len(optionalHeader) == 1 {
-			headers = optionalHeader[0]
-		} else {
-			headers = make(http.Header)
-		}
-		if _, found := headers["Content-Type"]; !found {
-			headers["Content-Type"] = []string{"application/x-protobuf"}
-		}
-		copyHeader(headers, w.Header())
-
-		w.WriteHeader(statusCode)
-		w.Write(data)
-	}
-}
-
 func VerifyRequest(method string, path interface{}, rawQuery ...string) http.HandlerFunc {
 	return NewGHTTPWithGomega(gomega.Default).VerifyRequest(method, path, rawQuery...)
 }
@@ -378,10 +325,6 @@
 	return NewGHTTPWithGomega(gomega.Default).VerifyFormKV(key, values...)
 }

-func VerifyProtoRepresenting(expected proto.Message) http.HandlerFunc {
-	return NewGHTTPWithGomega(gomega.Default).VerifyProtoRepresenting(expected)
-}
-
 func RespondWith(statusCode int, body interface{}, optionalHeader ...http.Header) http.HandlerFunc {
 	return NewGHTTPWithGomega(gomega.Default).RespondWith(statusCode, body, optionalHeader...)
 }
@@ -397,7 +340,3 @@
 func RespondWithJSONEncodedPtr(statusCode *int, object interface{}, optionalHeader ...http.Header) http.HandlerFunc {
 	return NewGHTTPWithGomega(gomega.Default).RespondWithJSONEncodedPtr(statusCode, object, optionalHeader...)
 }
-
-func RespondWithProto(statusCode int, message proto.Message, optionalHeader ...http.Header) http.HandlerFunc {
-	return NewGHTTPWithGomega(gomega.Default).RespondWithProto(statusCode, message, optionalHeader...)
-}
--- ./matchers/match_xml_matcher.go	2021-04-06 11:16:35.424198632 +0100
+++ ./matchers/match_xml_matcher.go	2021-04-06 10:59:11.104296549 +0100
@@ -11,7 +11,6 @@
 	"strings"

 	"github.com/bsm/gomega/format"
-	"golang.org/x/net/html/charset"
 )

 type MatchXMLMatcher struct {
@@ -110,9 +109,7 @@
 }

 func newXmlDecoder(reader io.Reader) *xml.Decoder {
-	dec := xml.NewDecoder(reader)
-	dec.CharsetReader = charset.NewReaderLabel
-	return dec
+	return xml.NewDecoder(reader)
 }

 func trimParentNodesContentSpaces(node *xmlNode) {
--- ./matchers.go	2021-04-06 11:16:35.416198634 +0100
+++ ./matchers.go	2021-04-06 11:00:24.848305975 +0100
@@ -223,15 +223,6 @@
 	}
 }

-//MatchYAML succeeds if actual is a string or stringer of YAML that matches
-//the expected YAML.  The YAML's are decoded and the resulting objects are compared via
-//reflect.DeepEqual so things like key-ordering and whitespace shouldn't matter.
-func MatchYAML(yaml interface{}) types.GomegaMatcher {
-	return &matchers.MatchYAMLMatcher{
-		YAMLToMatch: yaml,
-	}
-}
-
 //BeEmpty succeeds if actual is empty.  Actual must be of type string, array, map, chan, or slice.
 func BeEmpty() types.GomegaMatcher {
 	return &matchers.BeEmptyMatcher{}
Only in .: remove.patch
